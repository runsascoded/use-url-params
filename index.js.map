{"version":3,"sources":["../src/params.ts","../src/useUrlParam.ts","../src/index.ts"],"names":["encoded","parseParams"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Built-in parameter types with smart defaults and minimal encoding\n */\n\nimport type { Encoded, Param } from './index.js'\n\n/**\n * Optional string parameter.\n * - undefined → not present\n * - empty string → ?key=\n * - non-empty → ?key=value\n */\nexport function stringParam(init?: string): Param<string | undefined> {\n  return {\n    encode: (value) => value === init ? undefined : value,\n    decode: (encoded) => encoded === undefined ? init : encoded,\n  }\n}\n\n/**\n * Required string parameter with default.\n * Omitted from URL when equal to default.\n */\nexport function defStringParam(init: string): Param<string> {\n  return {\n    encode: (value) => value === init ? undefined : value,\n    decode: (encoded) => encoded ?? init,\n  }\n}\n\n/**\n * Boolean parameter.\n * - true → ?key (valueless)\n * - false → not present\n */\nexport const boolParam: Param<boolean> = {\n  encode: (value) => value ? '' : undefined,\n  decode: (encoded) => encoded !== undefined,\n}\n\n/**\n * Integer parameter with default.\n * Omitted from URL when equal to default.\n */\nexport function intParam(init: number): Param<number> {\n  return {\n    encode: (value) => value === init ? undefined : value.toString(),\n    decode: (encoded) => encoded !== undefined ? parseInt(encoded, 10) : init,\n  }\n}\n\n/**\n * Optional integer parameter.\n * - null → not present\n * - number → ?key=123\n */\nexport const optIntParam: Param<number | null> = {\n  encode: (value) => value === null ? undefined : value.toString(),\n  decode: (encoded) => encoded !== undefined ? parseInt(encoded, 10) : null,\n}\n\n/**\n * Float parameter with default.\n * Omitted from URL when equal to default.\n */\nexport function floatParam(init: number): Param<number> {\n  return {\n    encode: (value) => value === init ? undefined : value.toString(),\n    decode: (encoded) => encoded !== undefined ? parseFloat(encoded) : init,\n  }\n}\n\n/**\n * Enum parameter with validation.\n * Omitted from URL when equal to default.\n * Invalid values fall back to default with console warning.\n */\nexport function enumParam<T extends string>(\n  init: T,\n  values: readonly T[]\n): Param<T> {\n  const validSet = new Set(values)\n\n  return {\n    encode: (value) => {\n      if (!validSet.has(value)) {\n        console.warn(`Invalid enum value: ${value}, expected one of ${values.join(', ')}`)\n        return undefined\n      }\n      return value === init ? undefined : value\n    },\n    decode: (encoded) => {\n      if (encoded === undefined) return init\n      if (!validSet.has(encoded as T)) {\n        console.warn(`Invalid enum value: ${encoded}, expected one of ${values.join(', ')}. Using default: ${init}`)\n        return init\n      }\n      return encoded as T\n    },\n  }\n}\n\n/**\n * String array parameter with delimiter.\n * Omitted from URL when equal to default.\n * Empty array encodes as empty string (?key=)\n */\nexport function stringsParam(\n  init: string[] = [],\n  delimiter = ' '\n): Param<string[]> {\n  const initEncoded = init.join(delimiter)\n\n  return {\n    encode: (values) => {\n      const encoded = values.join(delimiter)\n      if (encoded === initEncoded) return undefined\n      return encoded\n    },\n    decode: (encoded) => {\n      if (encoded === undefined) return init\n      if (encoded === '') return []\n      return encoded.split(delimiter)\n    },\n  }\n}\n\n/**\n * Number array parameter.\n * Omitted from URL when equal to default.\n * Uses comma delimiter.\n */\nexport function numberArrayParam(init: number[] = []): Param<number[]> {\n  const isEqual = (a: number[], b: number[]) =>\n    a.length === b.length && a.every((v, i) => v === b[i])\n\n  return {\n    encode: (values) => {\n      if (isEqual(values, init)) return undefined\n      return values.map(v => v.toString()).join(',')\n    },\n    decode: (encoded) => {\n      if (encoded === undefined) return init\n      if (encoded === '') return []\n      return encoded.split(',').map(v => parseFloat(v))\n    },\n  }\n}\n","/**\n * React hook for managing URL query parameters\n */\n\nimport { useCallback, useEffect, useRef, useState, useSyncExternalStore } from 'react'\nimport type { Param } from './index.js'\nimport { getCurrentParams, parseParams, serializeParams } from './index.js'\n\n/**\n * Cached snapshot to prevent infinite loops in useSyncExternalStore\n */\nlet cachedSnapshot: Record<string, string | undefined> | null = null\nlet cachedSearch: string | null = null\n\n/**\n * Subscribe to URL changes (popstate events)\n */\nfunction subscribeToUrl(callback: () => void): () => void {\n  if (typeof window === 'undefined') return () => {}\n\n  window.addEventListener('popstate', callback)\n  return () => window.removeEventListener('popstate', callback)\n}\n\n/**\n * Get current URL search params as a snapshot\n * Returns cached snapshot if URL hasn't changed\n */\nfunction getUrlSnapshot(): Record<string, string | undefined> {\n  if (typeof window === 'undefined') return {}\n\n  const search = window.location.search\n\n  // Return cached snapshot if URL hasn't changed\n  if (cachedSearch === search && cachedSnapshot !== null) {\n    return cachedSnapshot\n  }\n\n  // URL changed, parse and cache new snapshot\n  cachedSearch = search\n  cachedSnapshot = getCurrentParams()\n  return cachedSnapshot\n}\n\n/**\n * Server-side snapshot (always empty)\n */\nfunction getServerSnapshot(): Record<string, string | undefined> {\n  return {}\n}\n\n/**\n * React hook for managing a single URL query parameter.\n *\n * @param key - Query parameter key\n * @param param - Param encoder/decoder\n * @param push - Use pushState (true) or replaceState (false) when updating\n * @returns Tuple of [value, setValue]\n *\n * @example\n * ```tsx\n * const [zoom, setZoom] = useUrlParam('z', boolParam())\n * const [device, setDevice] = useUrlParam('d', stringParam('default'))\n * ```\n */\nexport function useUrlParam<T>(\n  key: string,\n  param: Param<T>,\n  push = false\n): [T, (value: T) => void] {\n  // Use ref to avoid recreating setValue when param changes\n  const paramRef = useRef(param)\n  paramRef.current = param\n\n  // Subscribe to URL changes\n  const urlParams = useSyncExternalStore(\n    subscribeToUrl,\n    getUrlSnapshot,\n    getServerSnapshot\n  )\n\n  // Memoize decoded value based on encoded string\n  // If the URL param string hasn't changed, return the same object reference\n  const encoded = urlParams[key]\n  const cacheRef = useRef<{ encoded: typeof encoded; decoded: T } | null>(null)\n\n  if (cacheRef.current === null || cacheRef.current.encoded !== encoded) {\n    cacheRef.current = { encoded, decoded: param.decode(encoded) }\n  }\n  const value = cacheRef.current.decoded\n\n  // Update URL when value changes\n  const setValue = useCallback(\n    (newValue: T) => {\n      if (typeof window === 'undefined') return\n\n      const currentParams = getCurrentParams()\n      const encoded = paramRef.current.encode(newValue)\n\n      // Update this parameter\n      if (encoded === undefined) {\n        delete currentParams[key]\n      } else {\n        currentParams[key] = encoded\n      }\n\n      // Serialize and update URL\n      const url = new URL(window.location.href)\n      url.search = serializeParams(currentParams)\n\n      const method = push ? 'pushState' : 'replaceState'\n      window.history[method]({}, '', url.toString())\n\n      // Trigger popstate event to notify other hooks\n      window.dispatchEvent(new PopStateEvent('popstate'))\n    },\n    [key, push]\n  )\n\n  return [value, setValue]\n}\n\n/**\n * React hook for managing multiple URL query parameters together.\n * Updates are batched into a single history entry.\n *\n * @param params - Object mapping keys to Param types\n * @param push - Use pushState (true) or replaceState (false) when updating\n * @returns Object with decoded values and update function\n *\n * @example\n * ```tsx\n * const { values, setValues } = useUrlParams({\n *   zoom: boolParam(),\n *   device: stringParam('default'),\n *   count: intParam(10)\n * })\n *\n * // Update multiple params at once\n * setValues({ zoom: true, count: 20 })\n * ```\n */\nexport function useUrlParams<P extends Record<string, Param<any>>>(\n  params: P,\n  push = false\n): {\n  values: { [K in keyof P]: P[K] extends Param<infer T> ? T : never }\n  setValues: (updates: Partial<{ [K in keyof P]: P[K] extends Param<infer T> ? T : never }>) => void\n} {\n  // Subscribe to URL changes\n  const urlParams = useSyncExternalStore(\n    subscribeToUrl,\n    getUrlSnapshot,\n    getServerSnapshot\n  )\n\n  // Decode all values from URL\n  const values = Object.fromEntries(\n    Object.entries(params).map(([key, param]) => [\n      key,\n      param.decode(urlParams[key])\n    ])\n  ) as { [K in keyof P]: P[K] extends Param<infer T> ? T : never }\n\n  // Update multiple parameters at once\n  const setValues = useCallback(\n    (updates: Partial<{ [K in keyof P]: P[K] extends Param<infer T> ? T : never }>) => {\n      if (typeof window === 'undefined') return\n\n      const currentParams = getCurrentParams()\n\n      // Apply all updates\n      for (const [key, value] of Object.entries(updates)) {\n        const param = params[key]\n        if (!param) continue\n\n        const encoded = param.encode(value)\n        if (encoded === undefined) {\n          delete currentParams[key]\n        } else {\n          currentParams[key] = encoded\n        }\n      }\n\n      // Serialize and update URL once\n      const url = new URL(window.location.href)\n      url.search = serializeParams(currentParams)\n\n      const method = push ? 'pushState' : 'replaceState'\n      window.history[method]({}, '', url.toString())\n\n      // Trigger popstate event to notify other hooks\n      window.dispatchEvent(new PopStateEvent('popstate'))\n    },\n    [params, push]\n  )\n\n  return { values, setValues }\n}\n","/**\n * Core types and utilities for URL parameter management\n */\n\n/**\n * Encodes a value to a URL query parameter string.\n * - undefined: parameter not present in URL\n * - \"\": valueless parameter (e.g., ?z)\n * - string: parameter with value (e.g., ?z=foo)\n */\nexport type Encoded = string | undefined\n\n/**\n * A bidirectional converter between a typed value and its URL representation.\n */\nexport type Param<T> = {\n  encode: (value: T) => Encoded\n  decode: (encoded: Encoded) => T\n}\n\n/**\n * Serialize query parameters to URL string.\n * Uses URLSearchParams for proper form-urlencoded format (space → +)\n * Handles valueless params (empty string → ?key without =) manually\n */\nexport function serializeParams(params: Record<string, Encoded>): string {\n  const searchParams = new URLSearchParams()\n\n  for (const [key, value] of Object.entries(params)) {\n    if (value === undefined) {\n      // Skip undefined values\n      continue\n    } else if (value === '') {\n      // Valueless param: ?key without =\n      // URLSearchParams doesn't support this, so we'll handle manually\n      continue\n    } else {\n      searchParams.set(key, value)\n    }\n  }\n\n  let result = searchParams.toString()\n\n  // Handle valueless params manually\n  const valuelessKeys = Object.entries(params)\n    .filter(([_, value]) => value === '')\n    .map(([key, _]) => encodeURIComponent(key))\n\n  if (valuelessKeys.length > 0) {\n    const valuelessPart = valuelessKeys.join('&')\n    result = result ? `${result}&${valuelessPart}` : valuelessPart\n  }\n\n  return result\n}\n\n/**\n * Parse query parameters from URL string or URLSearchParams.\n * Note: URLSearchParams treats ?z and ?z= identically (both as empty string).\n */\nexport function parseParams(source: string | URLSearchParams): Record<string, Encoded> {\n  const searchParams = typeof source === 'string'\n    ? new URLSearchParams(source)\n    : source\n\n  const result: Record<string, Encoded> = {}\n\n  for (const [key, value] of searchParams.entries()) {\n    result[key] = value\n  }\n\n  return result\n}\n\n/**\n * Get current URL query parameters (browser only)\n */\nexport function getCurrentParams(): Record<string, Encoded> {\n  if (typeof window === 'undefined') return {}\n  return parseParams(window.location.search)\n}\n\n/**\n * Update URL without reloading (browser only)\n * @param params - New query parameters\n * @param push - Use pushState (true) or replaceState (false)\n */\nexport function updateUrl(params: Record<string, Encoded>, push = false): void {\n  if (typeof window === 'undefined') return\n\n  const url = new URL(window.location.href)\n  const search = serializeParams(params)\n  url.search = search\n\n  const method = push ? 'pushState' : 'replaceState'\n  window.history[method]({}, '', url.toString())\n}\n\nexport * from './params.js'\nexport * from './useUrlParam.js'\n"]}