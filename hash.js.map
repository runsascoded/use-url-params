{"version":3,"sources":["../src/core.ts","../src/params.ts","../src/multiParams.ts","../src/useUrlState.ts","../src/alphabet.ts","../src/binary.ts","../src/float.ts","../src/index.ts","../src/hash.ts"],"names":["arraysEqual"],"mappings":"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","file":"hash.js","sourcesContent":["/**\n * Core multi-value operations and location strategies\n */\n\n/**\n * Multi-value encoded representation\n * An array of strings representing multiple values for a single URL parameter key\n */\nexport type MultiEncoded = string[]\n\n/**\n * Location strategy interface for abstracting URL storage location\n * (query string vs hash fragment)\n */\nexport interface LocationStrategy {\n  /** Get raw string from location (for caching comparison) */\n  getRaw(): string\n  /** Parse current location to multi-value params */\n  parse(): Record<string, MultiEncoded>\n  /** Build URL string with updated params */\n  buildUrl(base: URL, params: Record<string, MultiEncoded>): string\n  /** Subscribe to location changes, returns unsubscribe function */\n  subscribe(callback: () => void): () => void\n}\n\n/**\n * Parse URL string to multi-value params\n * Each key maps to an array of all values for that key\n */\nexport function parseMultiParams(source: string | URLSearchParams): Record<string, MultiEncoded> {\n  const searchParams = typeof source === 'string'\n    ? new URLSearchParams(source)\n    : source\n\n  const result: Record<string, MultiEncoded> = {}\n  const keys = new Set(searchParams.keys())\n\n  for (const key of keys) {\n    result[key] = searchParams.getAll(key)\n  }\n\n  return result\n}\n\n/**\n * Serialize multi-value params to URL string format\n * Repeated keys are serialized as separate entries: key=a&key=b\n */\nexport function serializeMultiParams(params: Record<string, MultiEncoded>): string {\n  const searchParams = new URLSearchParams()\n\n  for (const [key, values] of Object.entries(params)) {\n    for (const value of values) {\n      if (value === '') {\n        // Valueless params handled separately\n        continue\n      }\n      searchParams.append(key, value)\n    }\n  }\n\n  let result = searchParams.toString()\n\n  // Handle valueless params (empty string values) manually\n  const valuelessKeys = Object.entries(params)\n    .filter(([_, values]) => values.includes(''))\n    .map(([key, _]) => encodeURIComponent(key))\n\n  if (valuelessKeys.length > 0) {\n    const valuelessPart = valuelessKeys.join('&')\n    result = result ? `${result}&${valuelessPart}` : valuelessPart\n  }\n\n  return result\n}\n\n/**\n * Custom event name for location changes triggered by History API\n */\nconst LOCATION_CHANGE_EVENT = 'use-prms:locationchange'\n\n/**\n * Patch History API to dispatch events on pushState/replaceState\n * This enables automatic reactivity to all programmatic URL changes\n */\nlet historyPatched = false\nfunction patchHistoryApi(): void {\n  if (typeof window === 'undefined' || historyPatched) return\n  historyPatched = true\n\n  const originalPushState = history.pushState.bind(history)\n  const originalReplaceState = history.replaceState.bind(history)\n\n  history.pushState = function(state, title, url) {\n    originalPushState(state, title, url)\n    window.dispatchEvent(new CustomEvent(LOCATION_CHANGE_EVENT))\n  }\n\n  history.replaceState = function(state, title, url) {\n    originalReplaceState(state, title, url)\n    window.dispatchEvent(new CustomEvent(LOCATION_CHANGE_EVENT))\n  }\n}\n\n// Patch on module load\npatchHistoryApi()\n\n/**\n * Query string location strategy\n * Reads/writes to window.location.search\n */\nexport const queryStrategy: LocationStrategy = {\n  getRaw(): string {\n    if (typeof window === 'undefined') return ''\n    return window.location.search\n  },\n\n  parse(): Record<string, MultiEncoded> {\n    if (typeof window === 'undefined') return {}\n    return parseMultiParams(window.location.search)\n  },\n\n  buildUrl(base: URL, params: Record<string, MultiEncoded>): string {\n    base.search = serializeMultiParams(params)\n    return base.toString()\n  },\n\n  subscribe(callback: () => void): () => void {\n    if (typeof window === 'undefined') return () => {}\n    window.addEventListener('popstate', callback)\n    window.addEventListener(LOCATION_CHANGE_EVENT, callback)\n    return () => {\n      window.removeEventListener('popstate', callback)\n      window.removeEventListener(LOCATION_CHANGE_EVENT, callback)\n    }\n  },\n}\n\n/**\n * Hash fragment location strategy\n * Reads/writes to window.location.hash\n * Hash is parsed as URLSearchParams format: #key=value&key2=value2\n */\nexport const hashStrategy: LocationStrategy = {\n  getRaw(): string {\n    if (typeof window === 'undefined') return ''\n    return window.location.hash\n  },\n\n  parse(): Record<string, MultiEncoded> {\n    if (typeof window === 'undefined') return {}\n    const hash = window.location.hash\n    // Remove leading # if present\n    const hashString = hash.startsWith('#') ? hash.slice(1) : hash\n    return parseMultiParams(hashString)\n  },\n\n  buildUrl(base: URL, params: Record<string, MultiEncoded>): string {\n    base.hash = serializeMultiParams(params)\n    return base.toString()\n  },\n\n  subscribe(callback: () => void): () => void {\n    if (typeof window === 'undefined') return () => {}\n    // Listen to hashchange, popstate, and our custom event for all navigation types\n    window.addEventListener('hashchange', callback)\n    window.addEventListener('popstate', callback)\n    window.addEventListener(LOCATION_CHANGE_EVENT, callback)\n    return () => {\n      window.removeEventListener('hashchange', callback)\n      window.removeEventListener('popstate', callback)\n      window.removeEventListener(LOCATION_CHANGE_EVENT, callback)\n    }\n  },\n}\n\n/**\n * Notify all use-prms hooks that the URL has changed.\n * Note: With the History API patch, this is rarely needed since pushState/replaceState\n * automatically trigger notifications. Use this for edge cases like direct location assignment.\n */\nexport function notifyLocationChange(): void {\n  if (typeof window === 'undefined') return\n  window.dispatchEvent(new CustomEvent(LOCATION_CHANGE_EVENT))\n}\n\n/**\n * Clear all URL params.\n * @param strategy - Which location to clear (query or hash), defaults to query\n */\nexport function clearParams(strategy: 'query' | 'hash' = 'query'): void {\n  if (typeof window === 'undefined') return\n  const url = new URL(window.location.href)\n  if (strategy === 'hash') {\n    url.hash = ''\n  } else {\n    url.search = ''\n  }\n  // replaceState triggers our custom event automatically via the patch\n  window.history.replaceState({ ...window.history.state }, '', url.toString())\n\n  // Notify React Router and other libraries that listen to popstate\n  window.dispatchEvent(new PopStateEvent('popstate'))\n}\n\n// Default strategy (can be changed by entry points like hash.ts)\nlet defaultStrategy: LocationStrategy = queryStrategy\n\n/**\n * Get the current default location strategy\n */\nexport function getDefaultStrategy(): LocationStrategy {\n  return defaultStrategy\n}\n\n/**\n * Set the default location strategy\n * Called by entry points (e.g., hash.ts sets this to hashStrategy)\n */\nexport function setDefaultStrategy(strategy: LocationStrategy): void {\n  defaultStrategy = strategy\n}\n","/**\n * Built-in parameter types with smart defaults and minimal encoding\n */\n\nimport type { Encoded, Param } from './index.js'\n\n/**\n * Optional string parameter.\n * - undefined  not present\n * - empty string  ?key=\n * - non-empty  ?key=value\n */\nexport function stringParam(init?: string): Param<string | undefined> {\n  return {\n    encode: (value) => value === init ? undefined : value,\n    decode: (encoded) => encoded === undefined ? init : encoded,\n  }\n}\n\n/**\n * Required string parameter with default.\n * Omitted from URL when equal to default.\n */\nexport function defStringParam(init: string): Param<string> {\n  return {\n    encode: (value) => value === init ? undefined : value,\n    decode: (encoded) => encoded ?? init,\n  }\n}\n\n/**\n * Boolean parameter.\n * - true  ?key (valueless)\n * - false  not present\n */\nexport const boolParam: Param<boolean> = {\n  encode: (value) => value ? '' : undefined,\n  decode: (encoded) => encoded !== undefined,\n}\n\n/**\n * Integer parameter with default.\n * Omitted from URL when equal to default.\n */\nexport function intParam(init: number): Param<number> {\n  return {\n    encode: (value) => value === init ? undefined : value.toString(),\n    decode: (encoded) => {\n      if (encoded === undefined || encoded === '') return init\n      const parsed = parseInt(encoded, 10)\n      return isNaN(parsed) ? init : parsed\n    },\n  }\n}\n\n/**\n * Optional integer parameter.\n * - null  not present\n * - number  ?key=123\n */\nexport const optIntParam: Param<number | null> = {\n  encode: (value) => value === null ? undefined : value.toString(),\n  decode: (encoded) => {\n    if (encoded === undefined || encoded === '') return null\n    const parsed = parseInt(encoded, 10)\n    return isNaN(parsed) ? null : parsed\n  },\n}\n\n/**\n * Enum parameter with validation.\n * Omitted from URL when equal to default.\n * Invalid values fall back to default with console warning.\n */\nexport function enumParam<T extends string>(\n  init: T,\n  values: readonly T[]\n): Param<T> {\n  const validSet = new Set(values)\n\n  return {\n    encode: (value) => {\n      if (!validSet.has(value)) {\n        console.warn(`Invalid enum value: ${value}, expected one of ${values.join(', ')}`)\n        return undefined\n      }\n      return value === init ? undefined : value\n    },\n    decode: (encoded) => {\n      if (encoded === undefined) return init\n      if (!validSet.has(encoded as T)) {\n        console.warn(`Invalid enum value: ${encoded}, expected one of ${values.join(', ')}. Using default: ${init}`)\n        return init\n      }\n      return encoded as T\n    },\n  }\n}\n\n/**\n * String array parameter with delimiter.\n * Omitted from URL when equal to default.\n * Empty array encodes as empty string (?key=)\n */\nexport function stringsParam(\n  init: string[] = [],\n  delimiter = ' '\n): Param<string[]> {\n  const initEncoded = init.join(delimiter)\n\n  return {\n    encode: (values) => {\n      const encoded = values.join(delimiter)\n      if (encoded === initEncoded) return undefined\n      return encoded\n    },\n    decode: (encoded) => {\n      if (encoded === undefined) return init\n      if (encoded === '') return []\n      return encoded.split(delimiter)\n    },\n  }\n}\n\n/**\n * Number array parameter.\n * Omitted from URL when equal to default.\n * Uses comma delimiter.\n */\nexport function numberArrayParam(init: number[] = []): Param<number[]> {\n  const isEqual = (a: number[], b: number[]) =>\n    a.length === b.length && a.every((v, i) => v === b[i])\n\n  return {\n    encode: (values) => {\n      if (isEqual(values, init)) return undefined\n      return values.map(v => v.toString()).join(',')\n    },\n    decode: (encoded) => {\n      if (encoded === undefined) return init\n      if (encoded === '') return []\n      return encoded.split(',').map(v => parseFloat(v))\n    },\n  }\n}\n\n/**\n * Pagination parameter combining offset and page size.\n * Uses space (which encodes as + in URLs) as delimiter.\n *\n * Encoding rules:\n * - offset=0, pageSize=default  not present (undefined)\n * - offset=0, pageSize=custom  \" pageSize\" (e.g., \" 20\"  +20 in URL)\n * - offset>0, pageSize=default  \"offset\" (e.g., \"100\")\n * - offset>0, pageSize=custom  \"offset pageSize\" (e.g., \"100 20\"  100+20 in URL)\n *\n * @param defaultPageSize - The default page size (omitted from URL when used)\n * @param validPageSizes - Optional array of valid page sizes for validation\n */\nexport type Pagination = { offset: number; pageSize: number }\n\nexport function paginationParam(\n  defaultPageSize: number,\n  validPageSizes?: readonly number[],\n): Param<Pagination> {\n  return {\n    encode: ({ offset, pageSize }) => {\n      if (offset === 0 && pageSize === defaultPageSize) return undefined\n      if (offset === 0) return ` ${pageSize}` // Space prefix  +pageSize in URL\n      if (pageSize === defaultPageSize) return String(offset)\n      return `${offset} ${pageSize}` // Space encodes as + in URL\n    },\n    decode: (encoded) => {\n      if (!encoded) return { offset: 0, pageSize: defaultPageSize }\n      const parts = encoded.split(' ') // URL + decodes to space\n      // Handle \" pageSize\" case (offset 0 with custom page size)\n      const offset = parts[0] === '' ? 0 : parseInt(parts[0], 10) || 0\n      let pageSize = parts[1] ? parseInt(parts[1], 10) : defaultPageSize\n      // Validate page size if validation array provided\n      if (validPageSizes && !validPageSizes.includes(pageSize)) {\n        pageSize = defaultPageSize\n      }\n      return { offset, pageSize }\n    },\n  }\n}\n\n/**\n * Code mapping for enum values - maps full values to short codes for compact URLs.\n * Can be specified as:\n * - Array of [value, code] tuples: [['Rides', 'r'], ['Minutes', 'm']]\n * - Object mapping values to codes: { Rides: 'r', Minutes: 'm' }\n */\nexport type CodeMap<T extends string> = [T, string][] | Record<T, string>\n\nfunction normalizeCodeMap<T extends string>(codeMap: CodeMap<T>): [T, string][] {\n  if (Array.isArray(codeMap)) return codeMap\n  return Object.entries(codeMap) as [T, string][]\n}\n\n/**\n * Single-value enum parameter with short code mapping.\n * Maps full enum values to abbreviated codes for compact URLs.\n * Omitted from URL when equal to default.\n *\n * @example\n * // ?y=r for \"Rides\", ?y=m for \"Minutes\", omitted for default \"Rides\"\n * codeParam('Rides', [['Rides', 'r'], ['Minutes', 'm']])\n * // or with object syntax:\n * codeParam('Rides', { Rides: 'r', Minutes: 'm' })\n */\nexport function codeParam<T extends string>(\n  init: T,\n  codeMap: CodeMap<T>,\n): Param<T> {\n  const entries = normalizeCodeMap(codeMap)\n  const valueToCode = new Map(entries)\n  const codeToValue = new Map(entries.map(([v, c]) => [c, v]))\n\n  return {\n    encode: (value) => {\n      if (value === init) return undefined\n      return valueToCode.get(value) ?? value\n    },\n    decode: (encoded) => {\n      if (encoded === undefined) return init\n      return codeToValue.get(encoded) ?? init\n    },\n  }\n}\n\n/**\n * Multi-value parameter with short code mapping.\n * Maps full values to abbreviated codes for compact URLs.\n * Omitted from URL when all values are selected.\n *\n * @param allValues - Array of all possible values (used to detect \"all selected\")\n * @param codeMap - Mapping from values to short codes\n * @param separator - Delimiter between codes (default: '' for most compact URLs)\n *\n * @example\n * // Regions: ?r=nj for NYC+JC, ?r=njh or omitted for all three\n * codesParam(['NYC', 'JC', 'HOB'], [['NYC', 'n'], ['JC', 'j'], ['HOB', 'h']])\n * // or with object syntax and custom separator:\n * codesParam(['NYC', 'JC', 'HOB'], { NYC: 'n', JC: 'j', HOB: 'h' }, ',')\n */\nexport function codesParam<T extends string>(\n  allValues: readonly T[],\n  codeMap: CodeMap<T>,\n  separator: string = '',\n): Param<T[]> {\n  const entries = normalizeCodeMap(codeMap)\n  const valueToCode = new Map(entries)\n  const codeToValue = new Map(entries.map(([v, c]) => [c, v]))\n\n  return {\n    encode: (values) => {\n      // Omit when all values selected\n      if (values.length === allValues.length && allValues.every(v => values.includes(v))) {\n        return undefined\n      }\n      return values.map(v => valueToCode.get(v) ?? v).join(separator)\n    },\n    decode: (encoded) => {\n      if (encoded === undefined) return [...allValues]\n      if (encoded === '') return []\n      const codes = separator ? encoded.split(separator) : encoded.split('')\n      return codes.map(c => codeToValue.get(c)).filter((v): v is T => v !== undefined)\n    },\n  }\n}\n","/**\n * Multi-value parameter types for handling repeated URL params\n * e.g., ?tag=a&tag=b&tag=c\n */\n\nimport type { MultiEncoded } from './core.js'\n\n/**\n * A bidirectional converter between a typed value and its multi-value URL representation.\n * Similar to Param<T> but works with string[] instead of string | undefined.\n */\nexport type MultiParam<T> = {\n  encode: (value: T) => MultiEncoded\n  decode: (encoded: MultiEncoded) => T\n}\n\n/**\n * Multi-value string array parameter.\n * Each string becomes a separate URL param with the same key.\n *\n * @example\n * // ?tag=a&tag=b&tag=c  ['a', 'b', 'c']\n * const [tags, setTags] = useMultiUrlState('tag', multiStringParam())\n */\nexport function multiStringParam(init: string[] = []): MultiParam<string[]> {\n  return {\n    encode: (values) => {\n      if (values.length === 0 && init.length === 0) return []\n      if (arraysEqual(values, init)) return []\n      return values\n    },\n    decode: (encoded) => {\n      if (encoded.length === 0) return init\n      return encoded\n    },\n  }\n}\n\n/**\n * Multi-value integer array parameter.\n * Each number becomes a separate URL param with the same key.\n *\n * @example\n * // ?id=1&id=2&id=3  [1, 2, 3]\n * const [ids, setIds] = useMultiUrlState('id', multiIntParam())\n */\nexport function multiIntParam(init: number[] = []): MultiParam<number[]> {\n  return {\n    encode: (values) => {\n      if (values.length === 0 && init.length === 0) return []\n      if (arraysEqual(values, init)) return []\n      return values.map(v => v.toString())\n    },\n    decode: (encoded) => {\n      if (encoded.length === 0) return init\n      return encoded.map(v => parseInt(v, 10))\n    },\n  }\n}\n\n/**\n * Multi-value float array parameter.\n * Each number becomes a separate URL param with the same key.\n *\n * @example\n * // ?val=1.5&val=2.7  [1.5, 2.7]\n * const [vals, setVals] = useMultiUrlState('val', multiFloatParam())\n */\nexport function multiFloatParam(init: number[] = []): MultiParam<number[]> {\n  return {\n    encode: (values) => {\n      if (values.length === 0 && init.length === 0) return []\n      if (arraysEqual(values, init)) return []\n      return values.map(v => v.toString())\n    },\n    decode: (encoded) => {\n      if (encoded.length === 0) return init\n      return encoded.map(v => parseFloat(v))\n    },\n  }\n}\n\n/** Helper to compare arrays for equality */\nfunction arraysEqual<T>(a: T[], b: T[]): boolean {\n  return a.length === b.length && a.every((v, i) => v === b[i])\n}\n","/**\n * React hooks for managing URL parameters\n */\n\nimport { useCallback, useEffect, useMemo, useRef, useSyncExternalStore } from 'react'\nimport type { Param } from './index.js'\nimport type { LocationStrategy, MultiEncoded } from './core.js'\nimport { getDefaultStrategy } from './core.js'\nimport type { MultiParam } from './multiParams.js'\n\n/**\n * Options for useUrlState hook\n */\nexport interface UseUrlStateOptions {\n  /**\n   * Debounce URL writes in milliseconds.\n   * State updates immediately, but URL updates are debounced.\n   * Useful for high-frequency updates (dragging, animation, typing).\n   * @default 0 (no debounce)\n   */\n  debounce?: number\n\n  /**\n   * Use pushState (true) or replaceState (false) when updating URL.\n   * @default false (replaceState)\n   */\n  push?: boolean\n}\n\n/**\n * Simple debounce implementation with cancel support\n */\nfunction debounce<T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n): T & { cancel: () => void } {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null\n\n  const debounced = ((...args: Parameters<T>) => {\n    if (timeoutId) clearTimeout(timeoutId)\n    timeoutId = setTimeout(() => {\n      timeoutId = null\n      fn(...args)\n    }, ms)\n  }) as T & { cancel: () => void }\n\n  debounced.cancel = () => {\n    if (timeoutId) {\n      clearTimeout(timeoutId)\n      timeoutId = null\n    }\n  }\n\n  return debounced\n}\n\n/**\n * Cached snapshot to prevent infinite loops in useSyncExternalStore\n * Keyed by strategy (so query and hash don't share cache)\n */\nconst snapshotCache = new WeakMap<LocationStrategy, {\n  raw: string\n  snapshot: Record<string, MultiEncoded>\n}>()\n\n/**\n * Get URL snapshot for a given strategy\n * Returns cached snapshot if URL hasn't changed\n */\nfunction getSnapshot(strategy: LocationStrategy): Record<string, MultiEncoded> {\n  const raw = strategy.getRaw()\n  const cached = snapshotCache.get(strategy)\n\n  if (cached && cached.raw === raw) {\n    return cached.snapshot\n  }\n\n  const snapshot = strategy.parse()\n  snapshotCache.set(strategy, { raw, snapshot })\n  return snapshot\n}\n\n/**\n * Server-side snapshot (always empty)\n */\nfunction getServerSnapshot(): Record<string, MultiEncoded> {\n  return {}\n}\n\n/**\n * Convert single-value Encoded to multi-value MultiEncoded\n */\nfunction singleToMulti(encoded: string | undefined): MultiEncoded {\n  if (encoded === undefined) return []\n  return [encoded]\n}\n\n/**\n * Convert multi-value MultiEncoded to single-value Encoded\n */\nfunction multiToSingle(multi: MultiEncoded): string | undefined {\n  if (multi.length === 0) return undefined\n  return multi[0]\n}\n\n/**\n * React hook for managing a single URL query parameter.\n *\n * Features:\n * - Bidirectional sync: state  URL\n * - Causality tracking: prevents feedback loops and lossy re-decoding\n * - Optional debounce for high-frequency updates\n *\n * @param key - Query parameter key\n * @param param - Param encoder/decoder\n * @param options - Options (debounce, push)\n * @returns Tuple of [value, setValue]\n *\n * @example\n * ```tsx\n * // Basic usage\n * const [zoom, setZoom] = useUrlState('z', boolParam)\n *\n * // With debounce for high-frequency updates\n * const [position, setPosition] = useUrlState('pos', floatParam(0), { debounce: 300 })\n * ```\n */\nexport function useUrlState<T>(\n  key: string,\n  param: Param<T>,\n  options: UseUrlStateOptions | boolean = {}\n): [T, (value: T) => void] {\n  // Handle legacy boolean `push` argument for backwards compatibility\n  const opts: UseUrlStateOptions = typeof options === 'boolean'\n    ? { push: options }\n    : options\n  const { debounce: debounceMs = 0, push = false } = opts\n\n  const strategy = getDefaultStrategy()\n\n  // Use ref to avoid recreating setValue when param changes\n  const paramRef = useRef(param)\n  paramRef.current = param\n\n  // Causality tracking: track what we last wrote to avoid re-decoding our own writes\n  // This prevents feedback loops and lossy snap-back with imprecise encodings\n  const lastWrittenRef = useRef<{\n    encoded: string | undefined\n    decoded: T\n  } | null>(null)\n\n  // Subscribe to URL changes\n  const urlParams = useSyncExternalStore(\n    (cb) => strategy.subscribe(cb),\n    () => getSnapshot(strategy),\n    getServerSnapshot\n  )\n\n  // Get encoded value from URL\n  const encoded = multiToSingle(urlParams[key] ?? [])\n\n  // Decode value with causality tracking\n  // If encoded matches what we last wrote, use our authoritative decoded value\n  // This avoids re-decoding (wasteful) and lossy snap-back (buggy)\n  const cacheRef = useRef<{ encoded: typeof encoded; param: Param<T>; decoded: T } | null>(null)\n\n  let value: T\n  if (lastWrittenRef.current && lastWrittenRef.current.encoded === encoded) {\n    // We caused this URL change - use our authoritative value\n    value = lastWrittenRef.current.decoded\n  } else {\n    // External change or initial load - decode from URL\n    if (cacheRef.current === null || cacheRef.current.encoded !== encoded || cacheRef.current.param !== param) {\n      cacheRef.current = { encoded, param, decoded: param.decode(encoded) }\n    }\n    value = cacheRef.current.decoded\n    // Clear lastWritten since URL now has external value\n    lastWrittenRef.current = null\n  }\n\n  // Create the URL write function\n  const writeToUrl = useCallback(\n    (newValue: T, newEncoded: string | undefined) => {\n      if (typeof window === 'undefined') return\n\n      const currentParams = strategy.parse()\n\n      // Update this parameter (single  multi)\n      if (newEncoded === undefined) {\n        delete currentParams[key]\n      } else {\n        currentParams[key] = [newEncoded]\n      }\n\n      // Build and update URL\n      const url = new URL(window.location.href)\n      const newUrl = strategy.buildUrl(url, currentParams)\n\n      const method = push ? 'pushState' : 'replaceState'\n      window.history[method]({ ...window.history.state }, '', newUrl)\n\n      // Notify React Router and other libraries that listen to popstate\n      window.dispatchEvent(new PopStateEvent('popstate'))\n    },\n    [key, push, strategy]\n  )\n\n  // Create debounced write if needed\n  const debouncedWriteRef = useRef<ReturnType<typeof debounce<typeof writeToUrl>> | null>(null)\n\n  // Setup/teardown debounced function when debounceMs changes\n  useEffect(() => {\n    if (debounceMs > 0) {\n      debouncedWriteRef.current = debounce(writeToUrl, debounceMs)\n    } else {\n      debouncedWriteRef.current = null\n    }\n    return () => {\n      debouncedWriteRef.current?.cancel()\n    }\n  }, [debounceMs, writeToUrl])\n\n  // Exposed setter: update causality tracking + write to URL (possibly debounced)\n  const setValue = useCallback(\n    (newValue: T) => {\n      const newEncoded = paramRef.current.encode(newValue)\n\n      // Track what we're writing for causality\n      lastWrittenRef.current = { encoded: newEncoded, decoded: newValue }\n\n      // Write to URL (debounced if configured)\n      if (debouncedWriteRef.current) {\n        debouncedWriteRef.current(newValue, newEncoded)\n      } else {\n        writeToUrl(newValue, newEncoded)\n      }\n    },\n    [writeToUrl]\n  )\n\n  return [value, setValue]\n}\n\n/**\n * React hook for managing multiple URL query parameters together.\n * Updates are batched into a single history entry.\n *\n * Features:\n * - Bidirectional sync: state  URL\n * - Causality tracking: prevents feedback loops and lossy re-decoding\n * - Optional debounce for high-frequency updates\n *\n * @param params - Object mapping keys to Param types\n * @param options - Options (debounce, push)\n * @returns Object with decoded values and update function\n *\n * @example\n * ```tsx\n * const { values, setValues } = useUrlStates({\n *   zoom: boolParam,\n *   device: stringParam('default'),\n *   count: intParam(10)\n * })\n *\n * // Update multiple params at once\n * setValues({ zoom: true, count: 20 })\n * ```\n */\nexport function useUrlStates<P extends Record<string, Param<any>>>(\n  params: P,\n  options: UseUrlStateOptions | boolean = {}\n): {\n  values: { [K in keyof P]: P[K] extends Param<infer T> ? T : never }\n  setValues: (updates: Partial<{ [K in keyof P]: P[K] extends Param<infer T> ? T : never }>) => void\n} {\n  // Handle legacy boolean `push` argument for backwards compatibility\n  const opts: UseUrlStateOptions = typeof options === 'boolean'\n    ? { push: options }\n    : options\n  const { debounce: debounceMs = 0, push = false } = opts\n\n  const strategy = getDefaultStrategy()\n\n  // Causality tracking: track what we last wrote per key\n  const lastWrittenRef = useRef<Record<string, { encoded: string | undefined; decoded: any }>>({})\n\n  // Subscribe to URL changes\n  const urlParams = useSyncExternalStore(\n    (cb) => strategy.subscribe(cb),\n    () => getSnapshot(strategy),\n    getServerSnapshot\n  )\n\n  // Decode all values from URL with causality tracking\n  const values = Object.fromEntries(\n    Object.entries(params).map(([key, param]) => {\n      const encoded = multiToSingle(urlParams[key] ?? [])\n      const lastWritten = lastWrittenRef.current[key]\n\n      if (lastWritten && lastWritten.encoded === encoded) {\n        // We caused this URL change - use our authoritative value\n        return [key, lastWritten.decoded]\n      } else {\n        // External change or initial load - decode from URL\n        const decoded = param.decode(encoded)\n        // Clear lastWritten for this key since URL now has external value\n        delete lastWrittenRef.current[key]\n        return [key, decoded]\n      }\n    })\n  ) as { [K in keyof P]: P[K] extends Param<infer T> ? T : never }\n\n  // Create the URL write function\n  const writeToUrl = useCallback(\n    (updates: Record<string, { encoded: string | undefined; decoded: any }>) => {\n      if (typeof window === 'undefined') return\n\n      const currentParams = strategy.parse()\n\n      // Apply all updates\n      for (const [key, { encoded }] of Object.entries(updates)) {\n        if (encoded === undefined) {\n          delete currentParams[key]\n        } else {\n          currentParams[key] = [encoded]\n        }\n      }\n\n      // Build and update URL once\n      const url = new URL(window.location.href)\n      const newUrl = strategy.buildUrl(url, currentParams)\n\n      const method = push ? 'pushState' : 'replaceState'\n      window.history[method]({ ...window.history.state }, '', newUrl)\n\n      // Notify React Router and other libraries that listen to popstate\n      window.dispatchEvent(new PopStateEvent('popstate'))\n    },\n    [push, strategy]\n  )\n\n  // Create debounced write if needed\n  const debouncedWriteRef = useRef<ReturnType<typeof debounce<typeof writeToUrl>> | null>(null)\n\n  useEffect(() => {\n    if (debounceMs > 0) {\n      debouncedWriteRef.current = debounce(writeToUrl, debounceMs)\n    } else {\n      debouncedWriteRef.current = null\n    }\n    return () => {\n      debouncedWriteRef.current?.cancel()\n    }\n  }, [debounceMs, writeToUrl])\n\n  // Update multiple parameters at once\n  const setValues = useCallback(\n    (updates: Partial<{ [K in keyof P]: P[K] extends Param<infer T> ? T : never }>) => {\n      const encodedUpdates: Record<string, { encoded: string | undefined; decoded: any }> = {}\n\n      for (const [key, value] of Object.entries(updates)) {\n        const param = params[key]\n        if (!param) continue\n\n        const encoded = param.encode(value)\n        encodedUpdates[key] = { encoded, decoded: value }\n        // Track what we're writing for causality\n        lastWrittenRef.current[key] = { encoded, decoded: value }\n      }\n\n      // Write to URL (debounced if configured)\n      if (debouncedWriteRef.current) {\n        debouncedWriteRef.current(encodedUpdates)\n      } else {\n        writeToUrl(encodedUpdates)\n      }\n    },\n    [params, writeToUrl]\n  )\n\n  return { values, setValues }\n}\n\n/**\n * React hook for managing a single multi-value URL parameter.\n * Supports repeated params like ?tag=a&tag=b&tag=c\n *\n * Features:\n * - Bidirectional sync: state  URL\n * - Causality tracking: prevents feedback loops and lossy re-decoding\n * - Optional debounce for high-frequency updates\n *\n * @param key - Query parameter key\n * @param param - MultiParam encoder/decoder\n * @param options - Options (debounce, push)\n * @returns Tuple of [value, setValue]\n *\n * @example\n * ```tsx\n * const [tags, setTags] = useMultiUrlState('tag', multiStringParam())\n * // URL: ?tag=a&tag=b  tags = ['a', 'b']\n * ```\n */\nexport function useMultiUrlState<T>(\n  key: string,\n  param: MultiParam<T>,\n  options: UseUrlStateOptions | boolean = {}\n): [T, (value: T) => void] {\n  // Handle legacy boolean `push` argument for backwards compatibility\n  const opts: UseUrlStateOptions = typeof options === 'boolean'\n    ? { push: options }\n    : options\n  const { debounce: debounceMs = 0, push = false } = opts\n\n  const strategy = getDefaultStrategy()\n\n  // Use ref to avoid recreating setValue when param changes\n  const paramRef = useRef(param)\n  paramRef.current = param\n\n  // Causality tracking: track what we last wrote\n  const lastWrittenRef = useRef<{\n    encoded: MultiEncoded\n    decoded: T\n  } | null>(null)\n\n  // Subscribe to URL changes\n  const urlParams = useSyncExternalStore(\n    (cb) => strategy.subscribe(cb),\n    () => getSnapshot(strategy),\n    getServerSnapshot\n  )\n\n  // Get encoded value from URL\n  const encoded = urlParams[key] ?? []\n\n  // Decode value with causality tracking\n  let value: T\n  if (lastWrittenRef.current && arraysEqual(lastWrittenRef.current.encoded, encoded)) {\n    // We caused this URL change - use our authoritative value\n    value = lastWrittenRef.current.decoded\n  } else {\n    // External change or initial load - decode from URL\n    value = param.decode(encoded)\n    // Clear lastWritten since URL now has external value\n    lastWrittenRef.current = null\n  }\n\n  // Create the URL write function\n  const writeToUrl = useCallback(\n    (newEncoded: MultiEncoded) => {\n      if (typeof window === 'undefined') return\n\n      const currentParams = strategy.parse()\n\n      // Update this parameter\n      if (newEncoded.length === 0) {\n        delete currentParams[key]\n      } else {\n        currentParams[key] = newEncoded\n      }\n\n      // Build and update URL\n      const url = new URL(window.location.href)\n      const newUrl = strategy.buildUrl(url, currentParams)\n\n      const method = push ? 'pushState' : 'replaceState'\n      window.history[method]({ ...window.history.state }, '', newUrl)\n\n      // Notify React Router and other libraries that listen to popstate\n      window.dispatchEvent(new PopStateEvent('popstate'))\n    },\n    [key, push, strategy]\n  )\n\n  // Create debounced write if needed\n  const debouncedWriteRef = useRef<ReturnType<typeof debounce<typeof writeToUrl>> | null>(null)\n\n  useEffect(() => {\n    if (debounceMs > 0) {\n      debouncedWriteRef.current = debounce(writeToUrl, debounceMs)\n    } else {\n      debouncedWriteRef.current = null\n    }\n    return () => {\n      debouncedWriteRef.current?.cancel()\n    }\n  }, [debounceMs, writeToUrl])\n\n  // Exposed setter\n  const setValue = useCallback(\n    (newValue: T) => {\n      const newEncoded = paramRef.current.encode(newValue)\n\n      // Track what we're writing for causality\n      lastWrittenRef.current = { encoded: newEncoded, decoded: newValue }\n\n      // Write to URL (debounced if configured)\n      if (debouncedWriteRef.current) {\n        debouncedWriteRef.current(newEncoded)\n      } else {\n        writeToUrl(newEncoded)\n      }\n    },\n    [writeToUrl]\n  )\n\n  return [value, setValue]\n}\n\n/** Helper to compare arrays for equality */\nfunction arraysEqual<T>(a: T[], b: T[]): boolean {\n  return a.length === b.length && a.every((v, i) => v === b[i])\n}\n\n/**\n * React hook for managing multiple multi-value URL parameters together.\n * Updates are batched into a single history entry.\n *\n * Features:\n * - Bidirectional sync: state  URL\n * - Causality tracking: prevents feedback loops and lossy re-decoding\n * - Optional debounce for high-frequency updates\n *\n * @param params - Object mapping keys to MultiParam types\n * @param options - Options (debounce, push)\n * @returns Object with decoded values and update function\n *\n * @example\n * ```tsx\n * const { values, setValues } = useMultiUrlStates({\n *   tags: multiStringParam(),\n *   ids: multiIntParam()\n * })\n *\n * // Update multiple multi-value params at once\n * setValues({ tags: ['a', 'b'], ids: [1, 2, 3] })\n * ```\n */\nexport function useMultiUrlStates<P extends Record<string, MultiParam<any>>>(\n  params: P,\n  options: UseUrlStateOptions | boolean = {}\n): {\n  values: { [K in keyof P]: P[K] extends MultiParam<infer T> ? T : never }\n  setValues: (updates: Partial<{ [K in keyof P]: P[K] extends MultiParam<infer T> ? T : never }>) => void\n} {\n  // Handle legacy boolean `push` argument for backwards compatibility\n  const opts: UseUrlStateOptions = typeof options === 'boolean'\n    ? { push: options }\n    : options\n  const { debounce: debounceMs = 0, push = false } = opts\n\n  const strategy = getDefaultStrategy()\n\n  // Causality tracking: track what we last wrote per key\n  const lastWrittenRef = useRef<Record<string, { encoded: MultiEncoded; decoded: any }>>({})\n\n  // Subscribe to URL changes\n  const urlParams = useSyncExternalStore(\n    (cb) => strategy.subscribe(cb),\n    () => getSnapshot(strategy),\n    getServerSnapshot\n  )\n\n  // Decode all values from URL with causality tracking\n  const values = Object.fromEntries(\n    Object.entries(params).map(([key, param]) => {\n      const encoded = urlParams[key] ?? []\n      const lastWritten = lastWrittenRef.current[key]\n\n      if (lastWritten && arraysEqual(lastWritten.encoded, encoded)) {\n        // We caused this URL change - use our authoritative value\n        return [key, lastWritten.decoded]\n      } else {\n        // External change or initial load - decode from URL\n        const decoded = param.decode(encoded)\n        // Clear lastWritten for this key since URL now has external value\n        delete lastWrittenRef.current[key]\n        return [key, decoded]\n      }\n    })\n  ) as { [K in keyof P]: P[K] extends MultiParam<infer T> ? T : never }\n\n  // Create the URL write function\n  const writeToUrl = useCallback(\n    (updates: Record<string, MultiEncoded>) => {\n      if (typeof window === 'undefined') return\n\n      const currentParams = strategy.parse()\n\n      // Apply all updates\n      for (const [key, encoded] of Object.entries(updates)) {\n        if (encoded.length === 0) {\n          delete currentParams[key]\n        } else {\n          currentParams[key] = encoded\n        }\n      }\n\n      // Build and update URL once\n      const url = new URL(window.location.href)\n      const newUrl = strategy.buildUrl(url, currentParams)\n\n      const method = push ? 'pushState' : 'replaceState'\n      window.history[method]({ ...window.history.state }, '', newUrl)\n\n      // Notify React Router and other libraries that listen to popstate\n      window.dispatchEvent(new PopStateEvent('popstate'))\n    },\n    [push, strategy]\n  )\n\n  // Create debounced write if needed\n  const debouncedWriteRef = useRef<ReturnType<typeof debounce<typeof writeToUrl>> | null>(null)\n\n  useEffect(() => {\n    if (debounceMs > 0) {\n      debouncedWriteRef.current = debounce(writeToUrl, debounceMs)\n    } else {\n      debouncedWriteRef.current = null\n    }\n    return () => {\n      debouncedWriteRef.current?.cancel()\n    }\n  }, [debounceMs, writeToUrl])\n\n  // Update multiple parameters at once\n  const setValues = useCallback(\n    (updates: Partial<{ [K in keyof P]: P[K] extends MultiParam<infer T> ? T : never }>) => {\n      const encodedUpdates: Record<string, MultiEncoded> = {}\n\n      for (const [key, value] of Object.entries(updates)) {\n        const param = params[key]\n        if (!param) continue\n\n        const encoded = param.encode(value)\n        encodedUpdates[key] = encoded\n        // Track what we're writing for causality\n        lastWrittenRef.current[key] = { encoded, decoded: value }\n      }\n\n      // Write to URL (debounced if configured)\n      if (debouncedWriteRef.current) {\n        debouncedWriteRef.current(encodedUpdates)\n      } else {\n        writeToUrl(encodedUpdates)\n      }\n    },\n    [params, writeToUrl]\n  )\n\n  return { values, setValues }\n}\n","/**\n * Base64 alphabet definitions and utilities\n *\n * Provides named presets for common base64 alphabets and validation.\n */\n\n/**\n * Named alphabet presets\n */\nexport const ALPHABETS = {\n  /**\n   * RFC 4648 base64url alphabet (default)\n   * Standard URL-safe encoding, but NOT lexicographically sortable.\n   */\n  rfc4648: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n\n  /**\n   * ASCII-ordered alphabet for lexicographic sortability\n   * Encoded strings sort in the same order as their numeric values.\n   * Uses URL-safe characters only (- and _).\n   */\n  sortable: '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz',\n} as const\n\n/**\n * Preset alphabet names\n */\nexport type AlphabetName = keyof typeof ALPHABETS\n\n/**\n * Alphabet specification: either a preset name or a 64-character string\n */\nexport type Alphabet = AlphabetName | (string & {})\n\n/**\n * URL-safe characters for base64 encoding\n */\nconst URL_SAFE_CHARS = /^[A-Za-z0-9\\-_]+$/\n\n/**\n * Validate an alphabet string\n * @throws Error if alphabet is invalid\n */\nexport function validateAlphabet(alphabet: string): void {\n  if (alphabet.length !== 64) {\n    throw new Error(`Alphabet must be exactly 64 characters, got ${alphabet.length}`)\n  }\n\n  const seen = new Set<string>()\n  for (const char of alphabet) {\n    if (seen.has(char)) {\n      throw new Error(`Duplicate character in alphabet: '${char}'`)\n    }\n    seen.add(char)\n  }\n\n  if (!URL_SAFE_CHARS.test(alphabet)) {\n    const unsafe = [...alphabet].filter(c => !URL_SAFE_CHARS.test(c))\n    throw new Error(`Alphabet contains non-URL-safe characters: ${unsafe.map(c => `'${c}'`).join(', ')}`)\n  }\n}\n\n/**\n * Resolve an alphabet specification to a 64-character string\n * @param alphabet - Preset name or 64-character string\n * @returns The resolved alphabet string\n * @throws Error if alphabet is invalid\n */\nexport function resolveAlphabet(alphabet: Alphabet): string {\n  if (alphabet in ALPHABETS) {\n    return ALPHABETS[alphabet as AlphabetName]\n  }\n\n  validateAlphabet(alphabet)\n  return alphabet\n}\n\n/**\n * Create a reverse lookup map for decoding\n */\nexport function createLookupMap(alphabet: string): Map<string, number> {\n  return new Map(alphabet.split('').map((c, i) => [c, i]))\n}\n","/**\n * Binary encoding utilities for compact URL parameters\n *\n * Provides base64url encoding for arbitrary binary data.\n * Use these to create compact URL representations of complex data structures.\n */\n\nimport { ALPHABETS, resolveAlphabet, validateAlphabet, createLookupMap, type Alphabet, type AlphabetName } from './alphabet.js'\n\n/**\n * URL-safe base64 alphabet (RFC 4648 base64url)\n * Uses - and _ instead of + and / for URL safety\n * @deprecated Use ALPHABETS.rfc4648 instead\n */\nconst BASE64_CHARS = ALPHABETS.rfc4648\n\n// Default lookup table for fast decoding (rfc4648)\nconst DEFAULT_LOOKUP = createLookupMap(ALPHABETS.rfc4648)\n\n// Cache for custom alphabet lookup maps\nconst lookupCache = new Map<string, Map<string, number>>()\n\nfunction getLookupMap(alphabet: string): Map<string, number> {\n  if (alphabet === ALPHABETS.rfc4648) return DEFAULT_LOOKUP\n  let lookup = lookupCache.get(alphabet)\n  if (!lookup) {\n    lookup = createLookupMap(alphabet)\n    lookupCache.set(alphabet, lookup)\n  }\n  return lookup\n}\n\n/**\n * Options for base64 encoding/decoding\n */\nexport interface Base64Options {\n  /**\n   * Alphabet to use: preset name or 64-character string\n   * @default 'rfc4648'\n   */\n  alphabet?: Alphabet\n}\n\n/**\n * Encode a Uint8Array to base64 string\n * @param bytes - The bytes to encode\n * @param options - Encoding options (alphabet)\n */\nexport function base64Encode(bytes: Uint8Array, options?: Base64Options): string {\n  const chars = options?.alphabet ? resolveAlphabet(options.alphabet) : ALPHABETS.rfc4648\n  let result = ''\n  let i = 0\n\n  while (i < bytes.length) {\n    const b0 = bytes[i++] ?? 0\n    const b1 = bytes[i++] ?? 0\n    const b2 = bytes[i++] ?? 0\n\n    // Combine 3 bytes into 24 bits, then split into 4 6-bit values\n    const n = (b0 << 16) | (b1 << 8) | b2\n\n    result += chars[(n >> 18) & 0x3f]\n    result += chars[(n >> 12) & 0x3f]\n\n    // Only add padding chars if we have the bytes\n    if (i - 2 < bytes.length) {\n      result += chars[(n >> 6) & 0x3f]\n    }\n    if (i - 1 < bytes.length) {\n      result += chars[n & 0x3f]\n    }\n  }\n\n  return result\n}\n\n/**\n * Decode a base64 string to Uint8Array\n * @param str - The base64 string to decode\n * @param options - Decoding options (alphabet)\n */\nexport function base64Decode(str: string, options?: Base64Options): Uint8Array {\n  const alphabet = options?.alphabet ? resolveAlphabet(options.alphabet) : ALPHABETS.rfc4648\n  const lookup = getLookupMap(alphabet)\n\n  // Remove any padding (we don't require it)\n  str = str.replace(/=+$/, '')\n\n  const bytes: number[] = []\n\n  for (let i = 0; i < str.length; i += 4) {\n    const c0 = lookup.get(str[i]) ?? 0\n    const c1 = lookup.get(str[i + 1]) ?? 0\n    const c2 = i + 2 < str.length ? lookup.get(str[i + 2]) ?? 0 : 0\n    const c3 = i + 3 < str.length ? lookup.get(str[i + 3]) ?? 0 : 0\n\n    // Combine 4 6-bit values into 24 bits, then split into 3 bytes\n    const n = (c0 << 18) | (c1 << 12) | (c2 << 6) | c3\n\n    bytes.push((n >> 16) & 0xff)\n    if (i + 2 < str.length) bytes.push((n >> 8) & 0xff)\n    if (i + 3 < str.length) bytes.push(n & 0xff)\n  }\n\n  return new Uint8Array(bytes)\n}\n\n/**\n * Options for binary param creation\n */\nexport interface BinaryParamOptions<T> {\n  /**\n   * Convert value to bytes\n   */\n  toBytes: (value: T) => Uint8Array\n\n  /**\n   * Convert bytes to value\n   */\n  fromBytes: (bytes: Uint8Array) => T\n\n  /**\n   * Alphabet to use: preset name or 64-character string\n   * @default 'rfc4648'\n   */\n  alphabet?: Alphabet\n}\n\nimport type { Param } from './index.js'\n\n/**\n * Create a param that encodes/decodes via binary representation\n *\n * This is a mid-level helper for creating custom binary-encoded params.\n * You provide toBytes/fromBytes converters, and it handles the base64url encoding.\n *\n * @example\n * ```ts\n * // Custom binary encoding for a shape array\n * const shapesParam = binaryParam<Shape[]>({\n *   toBytes: (shapes) => encodeShapesToBytes(shapes),\n *   fromBytes: (bytes) => decodeBytesToShapes(bytes),\n * })\n *\n * // Use with useUrlState\n * const [shapes, setShapes] = useUrlState('s', shapesParam)\n * ```\n */\nexport function binaryParam<T>(options: BinaryParamOptions<T>): Param<T | null> {\n  const { toBytes, fromBytes, alphabet } = options\n  const encodeOpts = alphabet ? { alphabet } : undefined\n\n  return {\n    encode: (value) => {\n      if (value === null) return undefined\n      const bytes = toBytes(value)\n      if (bytes.length === 0) return undefined\n      return base64Encode(bytes, encodeOpts)\n    },\n    decode: (encoded) => {\n      if (encoded === undefined || encoded === '') return null\n      try {\n        const bytes = base64Decode(encoded, encodeOpts)\n        return fromBytes(bytes)\n      } catch {\n        return null\n      }\n    },\n  }\n}\n\n/**\n * Create a base64-encoded binary param\n * Shorthand for binaryParam\n */\nexport function base64Param<T>(\n  toBytes: (value: T) => Uint8Array,\n  fromBytes: (bytes: Uint8Array) => T,\n  alphabet?: Alphabet\n): Param<T | null> {\n  return binaryParam({ toBytes, fromBytes, alphabet })\n}\n\n/**\n * Convert a 64-bit float to 8 bytes (IEEE 754 big-endian)\n */\nexport function floatToBytes(value: number): Uint8Array {\n  const buf = new ArrayBuffer(8)\n  const view = new DataView(buf)\n  view.setFloat64(0, value, false) // big-endian for consistent encoding\n  return new Uint8Array(buf)\n}\n\n/**\n * Convert 8 bytes to a 64-bit float (IEEE 754 big-endian)\n */\nexport function bytesToFloat(bytes: Uint8Array): number {\n  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  return view.getFloat64(0, false)\n}\n\n// Re-export alphabet utilities\nexport { ALPHABETS, resolveAlphabet, validateAlphabet, createLookupMap, type Alphabet, type AlphabetName } from './alphabet.js'\n\n/**\n * @deprecated Use ALPHABETS.rfc4648 instead\n */\nexport { BASE64_CHARS }\n","/**\n * Float encoding utilities for compact URL parameters\n *\n * Provides IEEE 754 decomposition, fixed-point conversion, and bit-level packing\n * for encoding floats with configurable precision.\n */\n\nimport { base64Encode, base64Decode, floatToBytes, bytesToFloat, type Base64Options, type Alphabet, resolveAlphabet, createLookupMap } from './binary.js'\n\n/**\n * Decomposed IEEE 754 double-precision float\n */\nexport interface Float {\n  neg: boolean\n  exp: number\n  mant: bigint\n}\n\n/**\n * Fixed-point representation with shared exponent\n */\nexport interface FixedPoint {\n  neg: boolean\n  exp: number\n  mant: bigint\n}\n\n/**\n * Precision scheme for fixed-point encoding\n */\nexport interface PrecisionScheme {\n  expBits: number\n  mantBits: number\n}\n\n/**\n * Predefined precision schemes for reference\n * Higher mantBits = more precision, larger URL\n */\nexport const precisionSchemes: PrecisionScheme[] = [\n  { expBits: 5, mantBits: 16 },  // ~5 decimal digits\n  { expBits: 5, mantBits: 22 },  // ~7 decimal digits\n  { expBits: 5, mantBits: 28 },  // ~8 decimal digits\n  { expBits: 5, mantBits: 34 },  // ~10 decimal digits\n  { expBits: 5, mantBits: 40 },  // ~12 decimal digits\n  { expBits: 5, mantBits: 46 },  // ~14 decimal digits\n  { expBits: 5, mantBits: 52 },  // ~16 decimal digits (near IEEE 754)\n]\n\n/** Default exponent bits (5 bits covers exponents -16 to +15) */\nconst DEFAULT_EXP_BITS = 5\n\n/** Min/max mantissa bits for bounds checking */\nconst MIN_MANT_BITS = 8\nconst MAX_MANT_BITS = 52\n\n/**\n * Resolve precision option to a PrecisionScheme\n * Accepts mantissa bits (number) or a full custom scheme\n */\nexport function resolvePrecision(precision: number | PrecisionScheme | undefined): PrecisionScheme {\n  if (precision === undefined) return { expBits: DEFAULT_EXP_BITS, mantBits: 22 } // sensible default\n  if (typeof precision === 'object') return precision\n  // precision is mantissa bits\n  if (precision < MIN_MANT_BITS || precision > MAX_MANT_BITS) {\n    throw new Error(`Precision must be ${MIN_MANT_BITS}-${MAX_MANT_BITS} bits, got ${precision}`)\n  }\n  return { expBits: DEFAULT_EXP_BITS, mantBits: precision }\n}\n\n// Shared buffer for float conversion\nconst floatBuf = new ArrayBuffer(8)\nconst floatView = new DataView(floatBuf)\n\n/**\n * Decompose an IEEE 754 double into sign, exponent, and mantissa\n */\nexport function toFloat(x: number): Float {\n  floatView.setFloat64(0, x, false) // big-endian\n  const byte0 = floatView.getUint8(0)\n  const neg = !!(byte0 & 0x80)\n  const exp = ((floatView.getUint16(0, false) & 0x7ff0) >> 4) - 1023\n  const mant = floatView.getBigUint64(0, false) & 0xfffffffffffffn\n  return { neg, exp, mant }\n}\n\n/**\n * Reconstruct a number from decomposed IEEE 754 components\n */\nexport function fromFloat({ neg, exp, mant }: Float): number {\n  floatView.setBigUint64(\n    0,\n    (neg ? 0x8000000000000000n : 0n) | (BigInt(exp + 1023) << 52n) | mant,\n    false\n  )\n  return floatView.getFloat64(0, false)\n}\n\n/**\n * Convert a decomposed float to fixed-point with specified mantissa bits\n */\nexport function toFixedPoint(\n  f: Float,\n  opts: { mantBits: number; exp?: number }\n): FixedPoint {\n  let { neg, exp: fExp, mant } = f\n  fExp++\n  const exp = opts.exp === undefined ? fExp : opts.exp\n\n  if (fExp > exp) {\n    throw Error(`maxExp ${exp} < ${fExp}`)\n  }\n\n  const downshiftBy = exp - fExp + 53 - opts.mantBits\n  const roundUp = mant & (1n << BigInt(downshiftBy - 1))\n  mant >>= BigInt(downshiftBy)\n  if (roundUp) {\n    mant += 1n\n  }\n  mant |= 1n << BigInt(opts.mantBits - 1 - (exp - fExp))\n  return { neg, exp, mant }\n}\n\n/**\n * Convert a fixed-point value back to decomposed float\n */\nexport function fromFixedPoint(f: FixedPoint, mantBits: number): Float {\n  const { neg } = f\n  const nonZeroBits = f.mant ? f.mant.toString(2).length : 0\n  const exp = f.exp - (mantBits - nonZeroBits) - 1\n\n  if (!f.mant) {\n    return { neg, exp: -1023, mant: 0n }\n  }\n\n  let mant = BigInt(f.mant)\n  mant = mant & ((1n << BigInt(nonZeroBits - 1)) - 1n)\n  mant <<= BigInt(f.exp - exp)\n  mant <<= BigInt(52 - mantBits)\n  return { neg, exp, mant }\n}\n\n/**\n * Bit-level buffer for packing/unpacking arbitrary bit widths\n *\n * Use this for custom binary encodings. Pack data with encodeInt/encodeBigInt,\n * then convert to base64 for URL-safe strings.\n *\n * @example\n * ```ts\n * // Encoding\n * const buf = new BitBuffer()\n * buf.encodeInt(myEnum, 3)      // 3 bits for enum\n * buf.encodeInt(myCount, 8)     // 8 bits for count\n * buf.encodeBigInt(myId, 48)    // 48 bits for ID\n * const urlParam = buf.toBase64()\n *\n * // Decoding\n * const buf = BitBuffer.fromBase64(urlParam)\n * const myEnum = buf.decodeInt(3)\n * const myCount = buf.decodeInt(8)\n * const myId = buf.decodeBigInt(48)\n * ```\n */\nexport class BitBuffer {\n  buf: number[]\n  byteOffset: number\n  bitOffset: number\n  end: number\n\n  constructor(numBytes?: number) {\n    this.buf = Array(numBytes || 0).fill(0)\n    this.byteOffset = 0\n    this.bitOffset = 0\n    this.end = 0\n  }\n\n  get totalBitOffset(): number {\n    return this.byteOffset * 8 + this.bitOffset\n  }\n\n  seek(totalBitOffset: number): BitBuffer {\n    this.byteOffset = totalBitOffset >> 3\n    this.bitOffset = totalBitOffset & 7\n    return this\n  }\n\n  /**\n   * Encode an integer with specified bit width\n   */\n  encodeInt(n: number, numBits: number): BitBuffer {\n    let { buf, byteOffset, bitOffset } = this\n\n    while (numBits > 0) {\n      if (byteOffset >= buf.length) {\n        buf.push(0)\n      }\n      const remainingBitsInByte = 8 - bitOffset\n      const bitsToWrite = Math.min(numBits, remainingBitsInByte)\n      const bitsLeftInByte = remainingBitsInByte - bitsToWrite\n      const bitsLeftToWrite = numBits - bitsToWrite\n      const mask = ((1 << bitsToWrite) - 1) << bitsLeftToWrite\n      const shiftedBitsToWrite = (n & mask) >> bitsLeftToWrite\n      buf[byteOffset] |= shiftedBitsToWrite << bitsLeftInByte\n      n &= (1 << bitsLeftToWrite) - 1\n      numBits -= bitsToWrite\n      bitOffset += bitsToWrite\n      if (bitOffset === 8) {\n        bitOffset = 0\n        byteOffset++\n      }\n    }\n\n    this.byteOffset = byteOffset\n    this.bitOffset = bitOffset\n    if (this.totalBitOffset > this.end) this.end = this.totalBitOffset\n    return this\n  }\n\n  /**\n   * Decode an integer with specified bit width\n   */\n  decodeInt(numBits: number): number {\n    let { buf, byteOffset, bitOffset } = this\n    let n = 0\n\n    while (numBits > 0) {\n      const remainingBitsInByte = 8 - bitOffset\n      const bitsToRead = Math.min(numBits, remainingBitsInByte)\n      const bitsLeftInByte = remainingBitsInByte - bitsToRead\n      const mask = ((1 << bitsToRead) - 1) << bitsLeftInByte\n      const bits = (buf[byteOffset] & mask) >> bitsLeftInByte\n      n = (n << bitsToRead) | bits\n      numBits -= bitsToRead\n      bitOffset += bitsToRead\n      if (bitOffset === 8) {\n        bitOffset = 0\n        byteOffset++\n      }\n    }\n\n    this.byteOffset = byteOffset\n    this.bitOffset = bitOffset\n    return n\n  }\n\n  /**\n   * Encode a bigint with specified bit width\n   */\n  encodeBigInt(n: bigint, numBits: number): BitBuffer {\n    let { buf, byteOffset, bitOffset } = this\n\n    while (numBits > 0) {\n      if (byteOffset >= buf.length) {\n        buf.push(0)\n      }\n      const remainingBitsInByte = 8 - bitOffset\n      const bitsToWrite = Math.min(numBits, remainingBitsInByte)\n      const bitsLeftInByte = remainingBitsInByte - bitsToWrite\n      const bitsLeftToWrite = numBits - bitsToWrite\n      const mask = ((1n << BigInt(bitsToWrite)) - 1n) << BigInt(bitsLeftToWrite)\n      const shiftedBitsToWrite = Number((n & mask) >> BigInt(bitsLeftToWrite))\n      buf[byteOffset] |= shiftedBitsToWrite << bitsLeftInByte\n      n &= (1n << BigInt(bitsLeftToWrite)) - 1n\n      numBits -= bitsToWrite\n      bitOffset += bitsToWrite\n      if (bitOffset === 8) {\n        bitOffset = 0\n        byteOffset++\n      }\n    }\n\n    this.byteOffset = byteOffset\n    this.bitOffset = bitOffset\n    if (this.totalBitOffset > this.end) this.end = this.totalBitOffset\n    return this\n  }\n\n  /**\n   * Decode a bigint with specified bit width\n   */\n  decodeBigInt(numBits: number): bigint {\n    let { buf, byteOffset, bitOffset } = this\n    let n = 0n\n\n    while (numBits > 0) {\n      const remainingBitsInByte = 8 - bitOffset\n      const bitsToRead = Math.min(numBits, remainingBitsInByte)\n      const bitsLeftInByte = remainingBitsInByte - bitsToRead\n      const mask = ((1 << bitsToRead) - 1) << bitsLeftInByte\n      const bits = BigInt((buf[byteOffset] & mask) >> bitsLeftInByte)\n      n = (n << BigInt(bitsToRead)) | bits\n      numBits -= bitsToRead\n      bitOffset += bitsToRead\n      if (bitOffset === 8) {\n        bitOffset = 0\n        byteOffset++\n      }\n    }\n\n    this.byteOffset = byteOffset\n    this.bitOffset = bitOffset\n    return n\n  }\n\n  /**\n   * Encode an array of floats with shared exponent\n   */\n  encodeFixedPoints(\n    vals: number[],\n    { expBits, mantBits }: PrecisionScheme\n  ): BitBuffer {\n    const floats = vals.map(toFloat)\n    const maxExp = Math.max(...floats.map(({ exp }) => exp + 1))\n\n    if (maxExp >= 1 << (expBits - 1)) {\n      throw Error(`maxExp ${maxExp} >= ${1 << expBits}`)\n    }\n\n    const expToWrite = (maxExp + (1 << (expBits - 1))) & ((1 << expBits) - 1)\n    this.encodeInt(expToWrite, expBits)\n\n    const fixedPoints = floats.map((f) => toFixedPoint(f, { mantBits, exp: maxExp }))\n    fixedPoints.forEach(({ neg, mant }) => {\n      this.encodeInt(neg ? 1 : 0, 1)\n      this.encodeBigInt(mant, mantBits)\n    })\n\n    return this\n  }\n\n  /**\n   * Decode an array of floats with shared exponent\n   */\n  decodeFixedPoints(\n    count: number,\n    { expBits, mantBits }: PrecisionScheme\n  ): number[] {\n    const expRaw = this.decodeInt(expBits)\n    const exp = expRaw - (1 << (expBits - 1))\n\n    const result: number[] = []\n    for (let i = 0; i < count; i++) {\n      const neg = this.decodeInt(1) === 1\n      const mant = this.decodeBigInt(mantBits)\n      const fp: FixedPoint = { neg, exp, mant }\n      const f = fromFixedPoint(fp, mantBits)\n      result.push(fromFloat(f))\n    }\n\n    return result\n  }\n\n  /**\n   * Get bytes as Uint8Array\n   */\n  toBytes(): Uint8Array {\n    const numBytes = Math.ceil(this.end / 8)\n    return new Uint8Array(this.buf.slice(0, numBytes))\n  }\n\n  /**\n   * Create from bytes\n   */\n  static fromBytes(bytes: Uint8Array): BitBuffer {\n    const buf = new BitBuffer()\n    buf.buf = Array.from(bytes)\n    buf.end = bytes.length * 8\n    return buf\n  }\n\n  /**\n   * Convert buffer to URL-safe base64 string\n   *\n   * Encodes bits directly to base64 (6 bits per character) for maximum compactness.\n   * This is more efficient than going through bytes when bit count isn't a multiple of 8.\n   *\n   * @param options - Base64 options (alphabet)\n   */\n  toBase64(options?: Base64Options): string {\n    const alphabet = resolveAlphabet(options?.alphabet ?? 'rfc4648')\n\n    // Pad to multiple of 6 bits\n    const overhang = this.end % 6\n    if (overhang) {\n      this.encodeInt(0, 6 - overhang)\n    }\n\n    const numChars = this.end / 6\n    this.seek(0)\n\n    let result = ''\n    for (let i = 0; i < numChars; i++) {\n      result += alphabet[this.decodeInt(6)]\n    }\n    return result\n  }\n\n  /**\n   * Create a BitBuffer from a URL-safe base64 string\n   *\n   * Decodes base64 directly to bits (6 bits per character).\n   *\n   * @param str - The base64 string to decode\n   * @param options - Base64 options (alphabet)\n   */\n  static fromBase64(str: string, options?: Base64Options): BitBuffer {\n    const alphabet = resolveAlphabet(options?.alphabet ?? 'rfc4648')\n    const lookup = createLookupMap(alphabet)\n\n    const buf = new BitBuffer()\n\n    for (const char of str) {\n      const idx = lookup.get(char)\n      if (idx === undefined) {\n        throw new Error(`Invalid base64 character: '${char}'`)\n      }\n      buf.encodeInt(idx, 6)\n    }\n\n    buf.seek(0)\n    return buf\n  }\n}\n\nimport type { Param } from './index.js'\n\n/**\n * Encoding mode for float params\n */\nexport type FloatEncoding = 'string' | 'base64'\n\n/**\n * Parse precision string like '5+22' into { exp, mant }\n */\nfunction parsePrecisionString(s: string): { exp: number; mant: number } {\n  const match = s.match(/^(\\d+)\\+(\\d+)$/)\n  if (!match) {\n    throw new Error(`Invalid precision format: \"${s}\". Expected format like \"5+22\" (exp+mant)`)\n  }\n  return { exp: parseInt(match[1], 10), mant: parseInt(match[2], 10) }\n}\n\n/**\n * Options for floatParam\n */\nexport interface FloatParamOptions {\n  /** Default value when param is missing */\n  default?: number\n  /** Encoding mode: 'base64' (default) or 'string' */\n  encoding?: FloatEncoding\n  /** For string encoding: number of decimal places */\n  decimals?: number\n  /** For lossy base64: exponent bits (requires mant) */\n  exp?: number\n  /** For lossy base64: mantissa bits (requires exp) */\n  mant?: number\n  /** For lossy base64: string shorthand like '5+22' (exp+mant) */\n  precision?: string\n  /** For base64: alphabet preset or 64-char string */\n  alphabet?: Alphabet\n}\n\n/**\n * Create a float param with configurable encoding\n *\n * @example\n * ```ts\n * // Lossless base64 (default) - 11 chars, exact\n * const f = floatParam(0)\n * const f = floatParam({ default: 0 })\n * const f = floatParam({ default: 0, encoding: 'base64' })\n *\n * // Lossy base64 - fewer chars, approximate\n * const f = floatParam({ default: 0, encoding: 'base64', exp: 5, mant: 22 })\n * const f = floatParam({ default: 0, encoding: 'base64', precision: '5+22' })\n *\n * // String encoding - full precision toString()\n * const f = floatParam({ default: 0, encoding: 'string' })\n *\n * // Truncated string - fixed decimal places\n * const f = floatParam({ default: 0, encoding: 'string', decimals: 6 })\n * ```\n */\nexport function floatParam(optsOrDefault: number | FloatParamOptions = 0): Param<number> {\n  // Handle simple number default\n  const opts: FloatParamOptions = typeof optsOrDefault === 'number'\n    ? { default: optsOrDefault }\n    : optsOrDefault\n\n  const {\n    default: defaultValue = 0,\n    encoding = 'base64',\n    decimals,\n    exp,\n    mant,\n    precision,\n    alphabet,\n  } = opts\n\n  // Validate options\n  if (encoding === 'string') {\n    if (exp !== undefined || mant !== undefined || precision !== undefined) {\n      throw new Error('exp/mant/precision options are only valid with encoding: \"base64\"')\n    }\n  }\n\n  if (encoding === 'base64') {\n    if (decimals !== undefined) {\n      throw new Error('decimals option is only valid with encoding: \"string\"')\n    }\n\n    // Check for lossy vs lossless\n    const hasExpMant = exp !== undefined || mant !== undefined\n    const hasPrecision = precision !== undefined\n\n    if (hasExpMant && hasPrecision) {\n      throw new Error('Cannot specify both exp/mant and precision')\n    }\n\n    if (hasExpMant) {\n      if (exp === undefined || mant === undefined) {\n        throw new Error('Both exp and mant must be specified together')\n      }\n      // Lossy base64 with explicit exp/mant\n      return createLossyBase64Param(defaultValue, { expBits: exp, mantBits: mant }, alphabet)\n    }\n\n    if (hasPrecision) {\n      // Lossy base64 with string precision\n      const { exp: e, mant: m } = parsePrecisionString(precision)\n      return createLossyBase64Param(defaultValue, { expBits: e, mantBits: m }, alphabet)\n    }\n\n    // Lossless base64 (default)\n    return createLosslessBase64Param(defaultValue, alphabet)\n  }\n\n  // String encoding\n  if (decimals !== undefined) {\n    return createTruncatedStringParam(defaultValue, decimals)\n  }\n\n  // Full precision string\n  return createFullStringParam(defaultValue)\n}\n\n/**\n * Lossless base64 encoding (full 64-bit IEEE 754)\n */\nfunction createLosslessBase64Param(defaultValue: number, alphabet?: Alphabet): Param<number> {\n  const opts = alphabet ? { alphabet } : undefined\n  return {\n    encode: (value) => {\n      if (value === defaultValue) return undefined\n      return base64Encode(floatToBytes(value), opts)\n    },\n    decode: (encoded) => {\n      if (encoded === undefined || encoded === '') return defaultValue\n      try {\n        return bytesToFloat(base64Decode(encoded, opts))\n      } catch {\n        return defaultValue\n      }\n    },\n  }\n}\n\n/**\n * Lossy base64 encoding (fixed-point with shared exponent)\n */\nfunction createLossyBase64Param(defaultValue: number, scheme: PrecisionScheme, alphabet?: Alphabet): Param<number> {\n  const opts = alphabet ? { alphabet } : undefined\n  return {\n    encode: (value) => {\n      if (value === defaultValue) return undefined\n      const buf = new BitBuffer()\n      buf.encodeFixedPoints([value], scheme)\n      return buf.toBase64(opts)\n    },\n    decode: (encoded) => {\n      if (encoded === undefined || encoded === '') return defaultValue\n      try {\n        const buf = BitBuffer.fromBase64(encoded, opts)\n        const [value] = buf.decodeFixedPoints(1, scheme)\n        return value\n      } catch {\n        return defaultValue\n      }\n    },\n  }\n}\n\n/**\n * Full precision string encoding (naive toString)\n */\nfunction createFullStringParam(defaultValue: number): Param<number> {\n  return {\n    encode: (value) => {\n      if (value === defaultValue) return undefined\n      return value.toString()\n    },\n    decode: (encoded) => {\n      if (encoded === undefined || encoded === '') return defaultValue\n      const parsed = parseFloat(encoded)\n      return isNaN(parsed) ? defaultValue : parsed\n    },\n  }\n}\n\n/**\n * Truncated string encoding (fixed decimal places)\n */\nfunction createTruncatedStringParam(defaultValue: number, decimals: number): Param<number> {\n  const multiplier = Math.pow(10, decimals)\n\n  return {\n    encode: (value) => {\n      if (value === defaultValue) return undefined\n      const truncated = Math.round(value * multiplier) / multiplier\n      return truncated.toFixed(decimals)\n    },\n    decode: (encoded) => {\n      if (encoded === undefined || encoded === '') return defaultValue\n      const parsed = parseFloat(encoded)\n      return isNaN(parsed) ? defaultValue : parsed\n    },\n  }\n}\n\n/**\n * Convenience wrapper for base64 float encoding\n *\n * @example\n * ```ts\n * base64FloatParam(0)                    // lossless\n * base64FloatParam({ exp: 5, mant: 22 }) // lossy\n * ```\n */\nexport function base64FloatParam(optsOrDefault: number | Omit<FloatParamOptions, 'encoding' | 'decimals'> = 0): Param<number> {\n  const opts = typeof optsOrDefault === 'number'\n    ? { default: optsOrDefault }\n    : optsOrDefault\n  return floatParam({ ...opts, encoding: 'base64' })\n}\n\n/**\n * 2D point type\n */\nexport interface Point {\n  x: number\n  y: number\n}\n\n/**\n * Options for point param\n */\nexport interface PointParamOptions {\n  /** Encoding mode */\n  encoding?: FloatEncoding\n  /** For string encoding: decimal places */\n  decimals?: number\n  /** For binary encoding: mantissa bits (8-52) or custom scheme. Default: 22 bits */\n  precision?: number | PrecisionScheme\n  /** Default point when param is missing */\n  default?: Point\n  /** For base64: alphabet preset or 64-char string */\n  alphabet?: Alphabet\n}\n\n/**\n * Create a param for encoding a 2D point\n *\n * String mode: \"x,y\" with truncated decimals\n * Binary mode: packed fixed-point with shared exponent\n *\n * @example\n * ```ts\n * // String encoding\n * const posParam = pointParam({ encoding: 'string', decimals: 2 })\n * posParam.encode({ x: 1.234, y: 5.678 }) // \"1.23 5.68\"\n *\n * // Binary encoding (more compact)\n * const posParam = pointParam({ encoding: 'base64', precision: 22 })\n * posParam.encode({ x: 1.234, y: 5.678 }) // compact base64\n * ```\n */\nexport function pointParam(opts: PointParamOptions = {}): Param<Point | null> {\n  const {\n    encoding = 'base64',\n    decimals = 2,\n    precision,\n    default: defaultPoint = null,\n    alphabet,\n  } = opts\n\n  const scheme = resolvePrecision(precision)\n  const multiplier = Math.pow(10, decimals)\n  const base64Opts = alphabet ? { alphabet } : undefined\n\n  return {\n    encode: (point) => {\n      if (point === null) return undefined\n      if (defaultPoint && point.x === defaultPoint.x && point.y === defaultPoint.y) {\n        return undefined\n      }\n\n      if (encoding === 'string') {\n        // String encoding: \"x y\" or \"x-y\" (space encodes as + in URLs)\n        // When y is negative, omit space - the minus sign acts as delimiter\n        const xTrunc = Math.round(point.x * multiplier) / multiplier\n        const yTrunc = Math.round(point.y * multiplier) / multiplier\n        // Always show full precision for consistent output length\n        const xStr = xTrunc.toFixed(decimals)\n        const yStr = yTrunc.toFixed(decimals)\n        // Only need space delimiter if y is non-negative\n        const delimiter = yTrunc >= 0 ? ' ' : ''\n        return `${xStr}${delimiter}${yStr}`\n      } else {\n        // Binary encoding with shared exponent\n        const buf = new BitBuffer()\n        buf.encodeFixedPoints([point.x, point.y], scheme)\n        return buf.toBase64(base64Opts)\n      }\n    },\n    decode: (encoded) => {\n      if (encoded === undefined || encoded === '') return defaultPoint\n\n      try {\n        if (encoding === 'string') {\n          // Split on space (URL decoding converts + back to space)\n          // If no space, look for minus sign (not at start) as delimiter\n          let x: number, y: number\n          if (encoded.includes(' ')) {\n            const parts = encoded.split(' ')\n            if (parts.length !== 2) return defaultPoint\n            x = parseFloat(parts[0])\n            y = parseFloat(parts[1])\n          } else {\n            // Find the minus sign that delimits y (skip any leading minus for x)\n            const minusIdx = encoded.indexOf('-', encoded[0] === '-' ? 1 : 0)\n            if (minusIdx === -1) return defaultPoint\n            x = parseFloat(encoded.slice(0, minusIdx))\n            y = parseFloat(encoded.slice(minusIdx))\n          }\n          if (isNaN(x) || isNaN(y)) return defaultPoint\n          return { x, y }\n        } else {\n          const buf = BitBuffer.fromBase64(encoded, base64Opts)\n          const [x, y] = buf.decodeFixedPoints(2, scheme)\n          return { x, y }\n        }\n      } catch {\n        return defaultPoint\n      }\n    },\n  }\n}\n\n/**\n * Encode a float to string and base64 representations for comparison\n *\n * Utility for demo/debugging to show encoding modes\n */\nexport function encodeFloatAllModes(\n  value: number,\n  opts: { decimals?: number; precision?: number | PrecisionScheme } = {}\n): { string: string; base64: string; bits: number } {\n  const { decimals = 2, precision } = opts\n  const scheme = resolvePrecision(precision)\n\n  // String encoding - always show full precision for consistent output length\n  const multiplier = Math.pow(10, decimals)\n  const truncated = Math.round(value * multiplier) / multiplier\n  const stringEncoded = truncated.toFixed(decimals)\n\n  // Binary encoding\n  const buf = new BitBuffer()\n  buf.encodeFixedPoints([value], scheme)\n\n  return {\n    string: stringEncoded,\n    base64: buf.toBase64(),\n    bits: buf.end,\n  }\n}\n\n/**\n * Encode a point to string and base64 representations for comparison\n */\nexport function encodePointAllModes(\n  point: Point,\n  opts: { decimals?: number; precision?: number | PrecisionScheme } = {}\n): { string: string; base64: string; bits: number } {\n  const { decimals = 2, precision } = opts\n  const scheme = resolvePrecision(precision)\n\n  // String encoding (space becomes + in URL, omit delimiter when y is negative)\n  const multiplier = Math.pow(10, decimals)\n  const xTrunc = Math.round(point.x * multiplier) / multiplier\n  const yTrunc = Math.round(point.y * multiplier) / multiplier\n  // Always show full precision for consistent output length\n  const xStr = xTrunc.toFixed(decimals)\n  const yStr = yTrunc.toFixed(decimals)\n  // Use + to show what actually appears in URL (space encodes as +)\n  const delimiter = yTrunc >= 0 ? '+' : ''\n  const stringEncoded = `${xStr}${delimiter}${yStr}`\n\n  // Binary encoding with shared exponent\n  const buf = new BitBuffer()\n  buf.encodeFixedPoints([point.x, point.y], scheme)\n\n  return {\n    string: stringEncoded,\n    base64: buf.toBase64(),\n    bits: buf.end,\n  }\n}\n\n// Re-export precision schemes\nexport { precisionSchemes as PRECISION_SCHEMES }\n","/**\n * Core types and utilities for URL parameter management\n */\n\n// Re-export core types and strategies\nexport type { MultiEncoded, LocationStrategy } from './core.js'\nexport {\n  parseMultiParams,\n  serializeMultiParams,\n  queryStrategy,\n  hashStrategy,\n  getDefaultStrategy,\n  setDefaultStrategy,\n  notifyLocationChange,\n  clearParams,\n} from './core.js'\n\n/**\n * Encodes a value to a URL query parameter string.\n * - undefined: parameter not present in URL\n * - \"\": valueless parameter (e.g., ?z)\n * - string: parameter with value (e.g., ?z=foo)\n */\nexport type Encoded = string | undefined\n\n/**\n * A bidirectional converter between a typed value and its URL representation.\n */\nexport type Param<T> = {\n  encode: (value: T) => Encoded\n  decode: (encoded: Encoded) => T\n}\n\n/**\n * Serialize query parameters to URL string.\n * Uses URLSearchParams for proper form-urlencoded format (space  +)\n * Handles valueless params (empty string  ?key without =) manually\n *\n * @deprecated For multi-value support, use serializeMultiParams instead\n */\nexport function serializeParams(params: Record<string, Encoded>): string {\n  const searchParams = new URLSearchParams()\n\n  for (const [key, value] of Object.entries(params)) {\n    if (value === undefined) {\n      // Skip undefined values\n      continue\n    } else if (value === '') {\n      // Valueless param: ?key without =\n      // URLSearchParams doesn't support this, so we'll handle manually\n      continue\n    } else {\n      searchParams.set(key, value)\n    }\n  }\n\n  let result = searchParams.toString()\n\n  // Handle valueless params manually\n  const valuelessKeys = Object.entries(params)\n    .filter(([_, value]) => value === '')\n    .map(([key, _]) => encodeURIComponent(key))\n\n  if (valuelessKeys.length > 0) {\n    const valuelessPart = valuelessKeys.join('&')\n    result = result ? `${result}&${valuelessPart}` : valuelessPart\n  }\n\n  return result\n}\n\n/**\n * Parse query parameters from URL string or URLSearchParams.\n * Note: URLSearchParams treats ?z and ?z= identically (both as empty string).\n * Note: For repeated params, only the first value is returned.\n *\n * @deprecated For multi-value support, use parseMultiParams instead\n */\nexport function parseParams(source: string | URLSearchParams): Record<string, Encoded> {\n  const searchParams = typeof source === 'string'\n    ? new URLSearchParams(source)\n    : source\n\n  const result: Record<string, Encoded> = {}\n\n  for (const [key, value] of searchParams.entries()) {\n    // Only take first value for each key (backward compat)\n    if (!(key in result)) {\n      result[key] = value\n    }\n  }\n\n  return result\n}\n\n/**\n * Get current URL query parameters (browser only)\n */\nexport function getCurrentParams(): Record<string, Encoded> {\n  if (typeof window === 'undefined') return {}\n  return parseParams(window.location.search)\n}\n\n/**\n * Update URL without reloading (browser only)\n * @param params - New query parameters\n * @param push - Use pushState (true) or replaceState (false)\n */\nexport function updateUrl(params: Record<string, Encoded>, push = false): void {\n  if (typeof window === 'undefined') return\n\n  const url = new URL(window.location.href)\n  const search = serializeParams(params)\n  url.search = search\n\n  const method = push ? 'pushState' : 'replaceState'\n  window.history[method]({ ...window.history.state }, '', url.toString())\n\n  // Notify React Router and other libraries that listen to popstate\n  window.dispatchEvent(new PopStateEvent('popstate'))\n}\n\nexport * from './params.js'\nexport * from './multiParams.js'\nexport * from './useUrlState.js'\nexport * from './alphabet.js'\nexport * from './binary.js'\nexport * from './float.js'\n","/**\n * Hash params entry point\n *\n * This module sets the default location strategy to hash (window.location.hash)\n * and re-exports everything from the main module.\n *\n * Usage:\n * ```typescript\n * // Instead of:\n * import { useUrlState, stringParam } from 'use-prms'\n *\n * // Use:\n * import { useUrlState, stringParam } from 'use-prms/hash'\n *\n * // Same API, but reads/writes to URL hash instead of query string\n * // e.g., #name=foo instead of ?name=foo\n * ```\n */\n\nimport { setDefaultStrategy, hashStrategy } from './core.js'\n\n// Set hash as the default strategy for this entry point\nsetDefaultStrategy(hashStrategy)\n\n// Re-export everything from main module\nexport * from './index.js'\n"]}